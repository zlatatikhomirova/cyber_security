from random import randint

def euclidean_extended_standart(a: int, b: int) -> tuple:
    """Реализация расширенного алгоритма Евклида. (стандартное отображение)
     Возвращает целое число x, y и gcd(a, b) для уравнения Безу:
         ax + by = НОД(a, b)."""

    """Инициализация начальных значений такая,
       потому что в алгоритме Евклида для нахождения НОД(a,b)
       используются выражения вида x_i = x_(i-2) - q*x_(i-1)
       и y_i = y_(i-2) - q*y_(i-1), где q - результат деления
       a на b в i-й итерации. Начальные значения x0 и y0
       выбираются так, чтобы можно было использовать формулу
       итерационного перехода и получить последующие значения
       x и y, не зная значения x и y на предыдущих шагах. """
    # инициализация начальных значений
    a_copy, b_copy = a, b
    x, xx, y, yy = 1, 0, 0, 1
    # пока можем делить - делим
    while b:
        q = a // b  # находим целую часть от деления a на b
        a, b = b, a % b  # переопределяем a и b, чтобы получить новые значения
        # обновляем соответствующие переменные (объяснение почему так есть выше)
        x, xx = xx, x - xx * q
        y, yy = yy, y - yy * q
    # возвращаем коэффициенты и НОД (здесь - а)
    return x, y, a

def even_div(u: int, v: int, a_copy: int, b_copy: int) -> tuple:
    # делаем u, v четными,
    # уменьшаем соответствующие
    # значения в 2 раза
    # без побитового сдвига, так как
    # есть работа с отрицат. числами
    if (u % 2 == 0) and (v % 2 == 0):
        u //= 2
        v //= 2
    else:
        u = (u + b_copy) // 2
        v = (v - a_copy) // 2
    return u, v
    
def euclidean_extended_binary(a: int, b: int) -> tuple:
    """Реализация расширенного алгоритма Евклида. (бинарное отображение)
       Возвращает коэффициенты x, y и gcd(a, b) для уравнения Безу:
       ax + by = НОД(a, b)."""
    u, v, x, y = 1, 0, 0, 1
    divisions = 0
    # деление на 2 заменяем на побитовый сдвиг
    # пока a четно и b четно
    while not ((a & 1) or (b & 1)):
        # a и b делим на 2
        a >>= 1
        b >>= 1
        # запоминаем количество делений
        divisions += 1
    a_copy, b_copy = a, b
    #
    # с этого момента мы сохраняем a = u * a_copy + v * b_copy
    # и b = x * a_copy + y * b_copy
    # пока a четно
    while not (a & 1):
        # a делим на 2
        a >>= 1
        # делаем u, v четными,
        # уменьшаем соответствующие
        # значения в 2 раза
        u, v = even_div(u, v, a_copy, b_copy)
    while a != b:
        if not (b & 1):
            b >>= 1
            # 
            # Комментарий: поскольку b четно,
             # (i) если x, y оба нечетны, то и a_copy и b_copy нечетны
             # (ii) если x нечетно, а y четно, то a_copy должна быть четной, поэтому b_copy нечетна
             # (iii) если y нечетно, а x четно, то b_copy должна быть четной, поэтому a_copy нечетна
             # так что для каждого из (i), (ii) и (iii) x + b_copy и y - a_copy четны
            #
            x, y = even_div(x, y, a_copy, b_copy)
        elif b < a:
            # если b < a,  меняем местами a, b и коэффициенты
            a, b, u, v, x, y = b, a, x, y, u, v
        else:
            # иначе - производим соответствующие вычитания
            b, x, y = b - a, x - u, y - v
    # возвращаем коэффициенты и НОД (здесь - а)
    return x, y, (2 ** divisions) * a

# константа для сравнения вещественных чисел
eps = 10e-8
def checker(a: int, b: int) -> None:
    """
    Функция проверяет, являются ли ответы двух функций истинными.
    Используется формула для нахождения произвольного решения уравнения ax + by = k, в нашем случае k = gcd
    """
    x1, y1, gcd1 = euclidean_extended_standart(a, b)
    x, y, gcd = euclidean_extended_binary(a, b)
    
    print(f"a: {a}\nb: {b}\n")
    print(f"euclidean_extended_standart\nx: {x1}\ny: {y1}\ngcd: {gcd1}\n")
    print(f"euclidean_extended_binary\nx: {x}\ny: {y}\ngcd: {gcd}\n\n")
    t1 = (x1 - x) / (-b/gcd1)
    t2 = (y1 - y) / (a/gcd1)
    # если это выполняется, то x, y - решения уравнения a*x + b*y = gcd
    assert (gcd1 == gcd) and (t1 - t2 < eps) and (t1 - int(t1) < eps), f"{a} {b}"

# 10 тестов
for i in range(1, 11):
    #для случайных чисел
    a = randint(1, 1000)
    b = randint(1, 1000)
    print(f"Test {i}\n")
    checker(a, b)
