import time

# константы алфавита и его размера
alphabet = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
ALPH_SIZE = len(alphabet)

def cnt_real(text):
    # функция считает реальные слова в дешифрованном тексте
    # получаем слова из текста
    words = set(filter(str.isalpha, text.lower().split()))
    cnt = 0
    # проходимся по словам из текста
    for word in words:
        # и по реальным словам
        for real_word in real_words:
            if word == real_word:
                cnt += 1
    return cnt

def change_case(letter1: str, substitution: str) -> str:
    # функция проверяет регистр буквы 
    # и сохраняет его таким же для
    # буквы-подстановки
    if letter1.isupper():
        return substitution.upper()
    return substitution
    
def decode(text: str, shift: int) -> str:
    # функция для дешифрования
    # инициализируем результирующую строку
    result = ''
    # мы в кольце делаем сдвиг влево (операция сдвига: индекс буквы в алфавите <оператор> на сколько сдвинуть)
    # проходимся по входному тексту
    for letter in text:
        # если текущая буква из входного текста есть в строке-алфавите для шифрования
        # буква для сравнения переведена в нижний регистр
        letter_for_comp = letter.lower()
        if letter_for_comp in alphabet:
            # находим индекс буквы из алфавита, 
            # которую надо будет поставить
            # в результирующей строке на место target,
            # соответствующее месту текущей букве в исходном тексте 
            # (1) получаем индекс буквы в алфавите
            # (2) в кольце 0..len(alphabet) находим индекс,
            # который будет соответствовать букве,
            # которую нужно будет вставить на target.
            # кольцо нужно, чтобы 'закольцевать' строку,
            # строить шифр последовательно
            idx = (alphabet.index(letter_for_comp) - shift) % len(alphabet)
            # добавляем найденную букву в результирующую строку
            # меняем регистр, чтобы не тест остался без изменений.
            result += change_case(letter, alphabet[idx])
        else:
            # если в алфавите такой буквы нет, 
            # то добавляем её в результирующую строку без изменений.
            result += letter
    # возвращаем результирующую строку
    return result

def indexes(alph: str) -> set:
    # функция для нахождения индексов букв в алфавите
    return {i : alphabet.index(i) for i in alph}
    
def get_alphabet(text: str) -> str:
    # функция для получения алфавита шифрованной строки
    # сначала сохраняем все уникальные буквы из текста
    alph_text = list(set(filter(str.isalpha, list(text.lower()))))
    # потом мы их упорядочиваем по встречаемости в тексте
    ordered_alph_text = sorted(alph_text, key=lambda x: text.count(x), reverse=True)
    # соединяем полученный алфавит в строку
    # алфавит, упорядоченный по встречаемости букв  (от большей к меньшей)       
    return "".join(ordered_alph_text)

def make_translation(text: str, ordered_alphabet:str, check:int) -> None:
    start_time = time.time()
    # принимает зашифрованную строку и алфавит, буквы которого используются в шифре
    # в нашем случае это русский алфавит
    # получаем зашифрованный алфавит,    # check - количество совпавших реальных слов в расшифрованном тексте
    # где буквы упорядочены по убыванию встречаемости в тексте
    ciph_ordered_alphabet = get_alphabet(text)
    ciph_ordered_alphabet += "".join(i for i in ordered_alphabet if i not in ciph_ordered_alphabet)
    # индексы нахождения букв 
    # русского алфавита, порядок букв -  по встречаемости букв  (от большей к меньшей)  
    # в исходном алфавите
    real_idx = indexes(ordered_alphabet)
    # индексы нахождения букв 
    # шифрованного алфавита, порядок букв -  по встречаемости букв  (от большей к меньшей)  
    # в исходном алфавите
    ciph_idx = indexes(ciph_ordered_alphabet)
    # счетчик для перемещения по алфавиту
    i = 0
    # перебираем, пока не нашли расшифровку и не вышли за границы строки.
    while i < ALPH_SIZE:
        # получаем сдвиг
        shift = abs(ciph_idx[ciph_ordered_alphabet[i]]- real_idx[ordered_alphabet[i]])
        # дешифруем исходный текст
        decoded_text = decode(text, shift)
        # вывод результата
        if cnt_real(decoded_text) >= check:
            
            print("Дешифрованный текст: ", decoded_text, sep='\n')
            print("\nВремя затраченное на расшифровку: %s c" % (time.time() - start_time))
            print("\nЕсли текст неправильно дешифрован, введите новый параметр check, отвечающий за количество реальных слов в дешифрованном тексте.")
            print("Если Вас все устраивает, нажмите Enter")
            # ответ пользователя
            ans = input("check : ")
            if ans.isdigit():
                print("-" * 30)
                check = int(ans)
                # следующая попытка расшифровки
                start_time = time.time()
                i = 0
            else:
                break
       # дальше по алфавиту
        i += 1
    print("Подбор при заданном параметре check невозможен. Выход...")
            
# исходный текст    
text = "Юяч эаыэау аэутчьуьчу юяэчадэтчб ёуяуц ыуыпяоьй, бощчу, щощ бэьщчу абуьщч щэяужщэр яоабуьчш чъч абуьщч щчжуёьчщо. Ыуыпяоьй цоыутънмб аэутчьчбуъкьйш юяэеуаа, ьэ ьу эабоьоръчромб усэ. Юяч эаыэау ыуыпяоьй хчрйд эясоьчцыэр юяэюващомб этьч рузуабро ч цотуяхчромб тявсчу. Лбэ эюяутуънубан ёоабчёьэ абяэуьчуы аоычд рузуабр."
              
# русский алфавит, упорядоченный по встречаемости букв  (от большей к меньшей)       
real_alph_desc = "оеаинтсрвлкмдпуяыьгзбчйхжшюцщэфёъ"

#реальные слова
#союзы
unions = ['и', 'а', 'но', 'или', 'да', 'ибо', 'то', 'хотя', 'чтобы']
#предлоги
prepositions = ['в', 'на', 'с', 'по', 'из', 'к', 'у', 'о', 'от', 'за', 'до', 'для', 'перед', 'через', 'со', 'под', 'об', 'про', 'между', 'над', 'при', 'после', 'около', 'возле', 'для', 'вокруг', 'вдоль', 'внутри', 'среди', 'вне', 'без', 'напротив', 'вслед']
#относительные местоимения
relative_pronouns = ["мой", "моя", "моё", "мои",
                      "твой", "твоя", "твоё", "твои",
                      "наш", "наша", "наше", "наши",
                      "ваш", "ваша", "ваше", "ваши"]
# личные местоимения
personal_prepositions = ["я", "ты", "он", "она", "оно", "мы", "вы", "они", "меня", "тебя", "мне", "тебе", "ему", "нам", "вам","меня", "тебя", "её", "его", "нас", "вас", "их", "мной", "тобой", "ей","им", "нами", "вами", "ими", "мне", "тебе", "нём", "ней", "нас", "вас", "них"]

# получаем список самых частых слов в русском языке
real_words = unions + prepositions + relative_pronouns + personal_prepositions
# дешифруем
check = 2
make_translation(text, real_alph_desc, check)

